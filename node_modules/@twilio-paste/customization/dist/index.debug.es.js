var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __assign = Object.assign;
var __rest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
  "use strict";
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return target.propertyIsEnumerable(symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object, property) {
    try {
      return property in object;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) {
      throw new Error("first argument should be an array");
    }
    return array.reduce(function(prev, next) {
      return deepmerge(prev, next, options);
    }, {});
  };
  var deepmerge_1 = deepmerge;
  module.exports = deepmerge_1;
});

// src/CustomizationProvider.tsx
import {
  createElement,
  useLayoutEffect,
  useMemo
} from "react";
import {useReducedMotion, Globals as AnimatedGlobals} from "@twilio-paste/animation-library";
import {StylingGlobals, ThemeProvider as StyledThemeProvider} from "@twilio-paste/styling-library";
import {pasteGlobalStyles, StyledBase, DefaultTheme, DarkTheme} from "@twilio-paste/theme";

// src/utils.ts
var merge = require_cjs();
var createCustomTheme = ({
  baseTheme,
  overrides,
  customBreakpoints,
  elements
}) => {
  const breakpoints = customBreakpoints || baseTheme.breakpoints;
  const mergedTheme = merge(baseTheme, overrides);
  if (elements != null) {
    const uniqueElements = [...new Set(Object.keys(elements).map((element) => element.toLowerCase()))];
    if (uniqueElements.length !== Object.keys(elements).length) {
      throw new Error("[CustomizationProvider]: duplicate element names, even when using a different casing, is not supported with Paste.");
    }
  }
  return __assign(__assign({}, mergedTheme), {
    breakpoints,
    elements
  });
};

// src/CustomizationProvider.tsx
var CustomizationProvider = (_a) => {
  var {
    baseTheme = "default",
    customBreakpoints,
    elements,
    theme,
    disableAnimations = false
  } = _a, props = __rest(_a, [
    "baseTheme",
    "customBreakpoints",
    "elements",
    "theme",
    "disableAnimations"
  ]);
  const customTheme = useMemo(() => createCustomTheme({
    baseTheme: baseTheme === "dark" ? DarkTheme : DefaultTheme,
    overrides: theme || {},
    elements: elements || {},
    customBreakpoints
  }), [baseTheme, customBreakpoints, elements, theme]);
  const prefersReducedMotion = useReducedMotion();
  useLayoutEffect(() => {
    AnimatedGlobals.assign({
      skipAnimation: disableAnimations || prefersReducedMotion
    });
  }, [disableAnimations, prefersReducedMotion]);
  return /* @__PURE__ */ createElement(StyledThemeProvider, {
    theme: customTheme
  }, /* @__PURE__ */ createElement(StylingGlobals, {
    styles: pasteGlobalStyles({theme: customTheme})
  }), /* @__PURE__ */ createElement(StyledBase, __assign({}, props)));
};

// src/CustomizationConsumer.tsx
import {
  createElement as createElement2
} from "react";
import {Theme} from "@twilio-paste/theme";
var CustomizationConsumer = (props) => {
  return /* @__PURE__ */ createElement2(Theme.Consumer, __assign({}, props));
};
export {
  CustomizationConsumer,
  CustomizationProvider
};
