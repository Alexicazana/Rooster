var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __assign = Object.assign;
var __rest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};

// ../../../../node_modules/lodash.iselement/index.js
var require_lodash = __commonJS((exports, module) => {
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function overArg(func4, transform) {
    return function(arg) {
      return func4(transform(arg));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isElement2(value) {
    return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isElement2;
});

// src/DataGrid.tsx
import {
  createElement,
  forwardRef,
  useCallback,
  useRef,
  useState
} from "react";
import {
  string
} from "prop-types";
import {Box} from "@twilio-paste/box";
import {useUID} from "@twilio-paste/uid-library";
import {useCompositeState, Composite} from "@twilio-paste/reakit-library";
import {Table} from "@twilio-paste/table";

// src/DataGridContext.tsx
import {
  createContext
} from "react";
var DataGridContext = createContext({
  actionable: false,
  striped: false
});

// src/utils/reakit/reakit-matches.ts
function matches(element, selectors) {
  if ("matches" in element) {
    return element.matches(selectors);
  }
  if ("msMatchesSelector" in element) {
    return element.msMatchesSelector(selectors);
  }
  return element.webkitMatchesSelector(selectors);
}

// src/utils/reakit/reakit-tabbable-modded.ts
var selector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])";
function isFocusable(element) {
  return matches(element, selector);
}
function getAllFocusableIn(container) {
  const allFocusable = Array.from(container.querySelectorAll(selector));
  return allFocusable.filter(isFocusable);
}
function getFirstFocusableIn(container) {
  const [first] = getAllFocusableIn(container);
  return first || null;
}

// src/utils/reakit/reakit-getDocument.ts
function getDocument(element) {
  return element ? element.ownerDocument || element : document;
}

// src/utils/reakit/reakit-getActiveElement-modded.ts
function getActiveElement(element) {
  const {activeElement} = getDocument(element);
  if (!(activeElement == null ? void 0 : activeElement.nodeName)) {
    return null;
  }
  return activeElement;
}

// src/utils/reakit/reakit-hasFocus.ts
function hasFocus(element) {
  const activeElement = getActiveElement(element);
  if (!activeElement)
    return false;
  if (activeElement === element)
    return true;
  const activeDescendant = activeElement.getAttribute("aria-activedescendant");
  if (!activeDescendant)
    return false;
  return activeDescendant === element.id;
}

// src/utils/reakit/reakit-ensureFocus.ts
function ensureFocus(element, {preventScroll, isActive = hasFocus} = {}) {
  if (isActive(element))
    return -1;
  element.focus({preventScroll});
  if (isActive(element))
    return -1;
  return requestAnimationFrame(() => {
    element.focus({preventScroll});
  });
}

// src/utils/cell-management.ts
var updateTabIndexForActionable = (cellElement, actionable) => {
  getAllFocusableIn(cellElement).forEach((element) => {
    element.tabIndex = actionable ? 0 : -1;
  });
};
var delayedSetFocusable = (element) => {
  setTimeout(() => {
    if (element != null) {
      element.tabIndex = 0;
    }
  }, 150);
};
var isCell = (element) => {
  return element.tagName === "TD" || element.tagName === "TH";
};
var getClosestCellFrom = (element, dataGridId) => {
  if (element == null)
    return null;
  if (!dataGridId)
    return null;
  return element.closest(`#${dataGridId} th, #${dataGridId} td`);
};
var getClosestGridCellFromCurrentFocus = (dataGridId) => {
  const focusedElement = getActiveElement();
  if (!focusedElement) {
    return null;
  }
  if (isCell(focusedElement)) {
    return focusedElement;
  }
  return getClosestCellFrom(focusedElement, dataGridId);
};

// src/DataGrid.tsx
var DataGrid = forwardRef((_a, ref) => {
  var {element = "DATA_GRID", striped = false} = _a, props = __rest(_a, ["element", "striped"]);
  const dataGridId = `data-grid-${useUID()}`;
  const lastFocusedElement = useRef(null);
  const compositeState = useCompositeState({unstable_virtual: false});
  const [actionable, setActionable] = useState(false);
  const handleMouseDown = useCallback(() => {
    setActionable(true);
  }, []);
  const handleFocus = useCallback((e) => {
    if (e.target != null) {
      lastFocusedElement.current = e.target;
    }
  }, []);
  const handleBlur = useCallback((event) => {
    const isDataGridBlurred = !event.currentTarget.contains(event.relatedTarget);
    if (isDataGridBlurred) {
      setActionable(false);
      if (lastFocusedElement.current != null) {
        const closestCell = getClosestCellFrom(lastFocusedElement.current, dataGridId);
        if (closestCell) {
          delayedSetFocusable(closestCell);
        }
      }
    }
  }, [dataGridId]);
  const handleKeypress = useCallback((event) => {
    switch (event.key) {
      case "Enter": {
        setActionable(true);
        const activeElement = getActiveElement();
        if (isCell(activeElement)) {
          const firstFocusableElement = getFirstFocusableIn(activeElement);
          if (firstFocusableElement) {
            ensureFocus(firstFocusableElement);
            activeElement.tabIndex = actionable ? 0 : -1;
          }
        }
        break;
      }
      case "Escape": {
        setActionable(false);
        const closestCell = getClosestGridCellFromCurrentFocus(dataGridId);
        if (closestCell) {
          ensureFocus(closestCell);
          delayedSetFocusable(closestCell);
        }
        break;
      }
      default:
        break;
    }
  }, [actionable, dataGridId]);
  const dataGridState = __assign(__assign({}, compositeState), {
    actionable,
    striped
  });
  return /* @__PURE__ */ createElement(DataGridContext.Provider, {
    value: dataGridState
  }, /* @__PURE__ */ createElement(Box, {
    id: dataGridId,
    element: `${element}_WRAPPER`,
    overflowX: "auto",
    whiteSpace: "nowrap",
    boxShadow: actionable ? "shadowFocus" : null
  }, /* @__PURE__ */ createElement(Composite, __assign(__assign(__assign({}, props), compositeState), {
    ref,
    as: Table,
    element,
    role: "grid",
    onKeyDown: handleKeypress,
    onMouseDown: handleMouseDown,
    onFocus: handleFocus,
    onBlur: handleBlur,
    "data-actionable": actionable
  }))));
});
DataGrid.displayName = "DataGrid";
DataGrid.propTypes = {
  "aria-label": string.isRequired,
  element: string
};

// src/DataGridHead.tsx
import {
  createElement as createElement2,
  forwardRef as forwardRef2
} from "react";
import {
  string as string2
} from "prop-types";
import {THead} from "@twilio-paste/table";
var DataGridHead = forwardRef2((_a, ref) => {
  var {element = "DATA_GRID_HEAD"} = _a, props = __rest(_a, ["element"]);
  return /* @__PURE__ */ createElement2(THead, __assign(__assign({}, props), {
    element,
    ref
  }));
});
DataGridHead.displayName = "DataGridHead";
DataGridHead.propTypes = {
  element: string2
};

// src/DataGridRow.tsx
import {
  createElement as createElement4,
  forwardRef as forwardRef4,
  useContext
} from "react";
import {
  bool as bool2,
  string as string4
} from "prop-types";
import {CompositeGroup} from "@twilio-paste/reakit-library";

// src/table/Tr.tsx
import {
  createElement as createElement3,
  forwardRef as forwardRef3
} from "react";
import {
  bool,
  string as string3
} from "prop-types";
import {Box as Box2, safelySpreadBoxProps} from "@twilio-paste/box";
var Tr = forwardRef3((_a, ref) => {
  var {element = "DATA_GRID_TR", striped} = _a, props = __rest(_a, ["element", "striped"]);
  return /* @__PURE__ */ createElement3(Box2, __assign(__assign({}, safelySpreadBoxProps(props)), {
    ref,
    element,
    as: "tr",
    "aria-selected": props.selected,
    borderStyle: "solid",
    borderColor: "colorBorderWeaker",
    borderWidth: "borderWidth0",
    borderBottomWidth: "borderWidth10",
    _even: {backgroundColor: striped ? "colorBackgroundRowStriped" : "transparent"},
    _last: {borderWidth: "borderWidth0"},
    _selected: {
      backgroundColor: "colorBackgroundPrimaryWeakest",
      borderColor: "colorBorderWeak"
    }
  }));
});
Tr.displayName = "Tr";
Tr.propTypes = {
  role: string3.isRequired,
  selected: bool,
  element: string3
};

// src/DataGridRow.tsx
var DataGridRow = forwardRef4((_a, ref) => {
  var {element = "DATA_GRID_ROW"} = _a, props = __rest(_a, ["element"]);
  const dataGridState = useContext(DataGridContext);
  return /* @__PURE__ */ createElement4(CompositeGroup, __assign(__assign(__assign(__assign({
    as: Tr
  }, props), {
    element
  }), dataGridState), {
    ref,
    role: "row"
  }));
});
DataGridRow.displayName = "DataGridRow";
DataGridRow.propTypes = {
  selected: bool2,
  element: string4
};

// src/DataGridHeader.tsx
import {
  createElement as createElement8
} from "react";
import {
  string as string8
} from "prop-types";

// src/DataGridCell.tsx
import {
  createElement as createElement7,
  useCallback as useCallback2,
  useContext as useContext2,
  useEffect,
  useRef as useRef2
} from "react";
import {
  oneOf,
  string as string7
} from "prop-types";
import {CompositeItem} from "@twilio-paste/reakit-library";
import {useMutationObservable} from "@twilio-paste/utils";

// src/table/Td.tsx
import {
  createElement as createElement5,
  forwardRef as forwardRef5
} from "react";
import {
  func,
  string as string5
} from "prop-types";
import {Box as Box3, safelySpreadBoxProps as safelySpreadBoxProps2} from "@twilio-paste/box";
var Td = forwardRef5((_a, ref) => {
  var {textAlign = "left", element = "DATA_GRID_TD"} = _a, props = __rest(_a, ["textAlign", "element"]);
  return /* @__PURE__ */ createElement5(Box3, __assign(__assign({}, safelySpreadBoxProps2(props)), {
    ref,
    as: "td",
    element,
    fontSize: "fontSize30",
    lineHeight: "lineHeight30",
    paddingY: "space40",
    paddingX: "space50",
    position: "relative",
    textAlign,
    verticalAlign: "inherit",
    wordWrap: "break-word",
    _first: {
      paddingLeft: "space50"
    },
    _last: {
      paddingRight: "space50"
    },
    _focus: {
      outline: "none",
      boxShadow: "shadowFocusInset"
    }
  }));
});
Td.displayName = "Td";
Td.propTypes = {
  onClick: func,
  element: string5
};

// src/table/Th.tsx
import {
  createElement as createElement6,
  forwardRef as forwardRef6
} from "react";
import {
  func as func2,
  string as string6
} from "prop-types";
import {Box as Box4, safelySpreadBoxProps as safelySpreadBoxProps3} from "@twilio-paste/box";
var Th = forwardRef6((_a, ref) => {
  var {width, textAlign = "left", element = "DATA_GRID_TH"} = _a, props = __rest(_a, ["width", "textAlign", "element"]);
  return /* @__PURE__ */ createElement6(Box4, __assign(__assign({}, safelySpreadBoxProps3(props)), {
    ref,
    element,
    as: "th",
    fontSize: "fontSize30",
    lineHeight: "lineHeight30",
    fontWeight: "fontWeightSemibold",
    paddingY: "space40",
    paddingX: "space50",
    width,
    position: "relative",
    textAlign,
    verticalAlign: "inherit",
    _first: {
      paddingLeft: "space50"
    },
    _last: {
      paddingRight: "space50"
    },
    _focus: {
      outline: "none",
      boxShadow: "shadowFocusInset"
    }
  }));
});
Th.displayName = "Th";
Th.propTypes = {
  onClick: func2,
  width: string6,
  element: string6
};

// src/DataGridCell.tsx
var isElement = require_lodash();
var DataGridCell = (_a) => {
  var {element = "DATA_GRID_CELL", as = "td"} = _a, props = __rest(_a, ["element", "as"]);
  const dataGridState = useContext2(DataGridContext);
  const cellRef = useRef2();
  const handleMouseDown = useCallback2(() => {
    ensureFocus(cellRef.current);
  }, []);
  const onListMutation = useCallback2((mutationList) => {
    if (mutationList.length === 0) {
      return;
    }
    mutationList.forEach((mutation) => {
      if (!isElement(mutation.target)) {
        return;
      }
      const target = mutation.target;
      if (mutation.attributeName === "tabindex" && dataGridState.actionable && target.tabIndex === 0 && isCell(target)) {
        target.tabIndex = -1;
      }
    });
  }, [dataGridState.actionable]);
  useMutationObservable(cellRef.current, onListMutation);
  useEffect(() => {
    if (cellRef.current) {
      updateTabIndexForActionable(cellRef.current, dataGridState.actionable);
    }
  }, [dataGridState.actionable]);
  return /* @__PURE__ */ createElement7(CompositeItem, __assign(__assign(__assign({}, props), dataGridState), {
    element,
    ref: cellRef,
    as: as === "td" ? Td : Th,
    onClick: handleMouseDown
  }));
};
DataGridCell.displayName = "DataGridCell";
DataGridCell.propTypes = {
  as: oneOf(["th", "td"]),
  element: string7
};

// src/DataGridHeader.tsx
var DataGridHeader = (_a) => {
  var {element = "DATA_GRID_HEADER"} = _a, props = __rest(_a, ["element"]);
  return /* @__PURE__ */ createElement8(DataGridCell, __assign(__assign({
    element
  }, props), {
    as: "th"
  }));
};
DataGridHeader.displayName = "DataGridHeader";
DataGridHeader.propTypes = {
  element: string8
};

// src/DataGridHeaderSort.tsx
import {
  createElement as createElement9
} from "react";
import {
  func as func3,
  oneOf as oneOf2,
  string as string9
} from "prop-types";
import {Button} from "@twilio-paste/button";
import {ArrowDownIcon} from "@twilio-paste/icons/esm/ArrowDownIcon";
import {ArrowUpIcon} from "@twilio-paste/icons/esm/ArrowUpIcon";
import {UnsortedIcon} from "@twilio-paste/icons/esm/UnsortedIcon";
var DataGridHeaderSortIcon = ({direction, element}) => {
  switch (direction) {
    case "ascending":
      return /* @__PURE__ */ createElement9(ArrowUpIcon, {
        decorative: false,
        element,
        title: "Sort ascending"
      });
    case "descending":
      return /* @__PURE__ */ createElement9(ArrowDownIcon, {
        decorative: false,
        element,
        title: "Sort descending"
      });
    case "none":
      return /* @__PURE__ */ createElement9(UnsortedIcon, {
        decorative: false,
        element,
        title: "Unsorted"
      });
    default:
      return null;
  }
};
var DataGridHeaderSort = (_a) => {
  var {
    direction,
    onClick,
    element = "DATA_GRID_HEADER_SORT"
  } = _a, props = __rest(_a, [
    "direction",
    "onClick",
    "element"
  ]);
  return /* @__PURE__ */ createElement9(Button, __assign({
    element,
    variant: "reset",
    size: "reset",
    onClick
  }, props), /* @__PURE__ */ createElement9(DataGridHeaderSortIcon, {
    element: `${element}_ICON`,
    direction
  }));
};
DataGridHeaderSort.displayName = "DataGridHeaderSort";
DataGridHeaderSort.propTypes = {
  direction: oneOf2(["ascending", "descending", "none"]).isRequired,
  onClick: func3,
  element: string9
};

// src/DataGridBody.tsx
import {
  createElement as createElement10,
  forwardRef as forwardRef7
} from "react";
import {
  string as string10
} from "prop-types";
import {TBody} from "@twilio-paste/table";
var DataGridBody = forwardRef7((_a, ref) => {
  var {element = "DATA_GRID_BODY"} = _a, props = __rest(_a, ["element"]);
  return /* @__PURE__ */ createElement10(TBody, __assign(__assign({}, props), {
    element,
    ref
  }));
});
DataGridBody.displayName = "DataGridBody";
DataGridBody.propTypes = {
  element: string10
};

// src/DataGridFoot.tsx
import {
  createElement as createElement11,
  forwardRef as forwardRef8
} from "react";
import {
  string as string11
} from "prop-types";
import {TFoot} from "@twilio-paste/table";
var DataGridFoot = forwardRef8((_a, ref) => {
  var {element = "DATA_GRID_FOOT"} = _a, props = __rest(_a, ["element"]);
  return /* @__PURE__ */ createElement11(TFoot, __assign(__assign({}, props), {
    element,
    ref
  }));
});
DataGridFoot.displayName = "DataGridFoot";
DataGridFoot.propTypes = {
  element: string11
};
export {
  DataGrid,
  DataGridBody,
  DataGridCell,
  DataGridFoot,
  DataGridHead,
  DataGridHeader,
  DataGridHeaderSort,
  DataGridRow
};
