var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __assign = Object.assign;
var __rest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/Grid.tsx
import {
  Children,
  cloneElement,
  createElement,
  forwardRef,
  isValidElement,
  useMemo
} from "react";
import {
  bool,
  node,
  string
} from "prop-types";
import {ResponsiveProp} from "@twilio-paste/style-props";
import {Box, safelySpreadBoxProps} from "@twilio-paste/box";

// src/utils.tsx
var initDefaultSpacing = ({
  prefix,
  responsive,
  defaultValue
}) => {
  const getSpaceDefault = () => responsive ? new Array(3).fill(defaultValue) : defaultValue;
  return {
    [`${prefix}Top`]: getSpaceDefault(),
    [`${prefix}Bottom`]: getSpaceDefault(),
    [`${prefix}Right`]: getSpaceDefault(),
    [`${prefix}Left`]: getSpaceDefault()
  };
};
var getDefaultSpacingValue = (prefix) => prefix === "margin" ? "auto" : "space0";
var getSpacing = (vertical, prefix, spacing) => {
  const defaultValue = getDefaultSpacingValue(prefix);
  const computedSpacing = initDefaultSpacing({prefix, responsive: false, defaultValue});
  if (spacing === void 0) {
    return computedSpacing;
  }
  if (vertical) {
    computedSpacing[`${prefix}Top`] = spacing;
    computedSpacing[`${prefix}Bottom`] = spacing;
  } else {
    computedSpacing[`${prefix}Right`] = spacing;
    computedSpacing[`${prefix}Left`] = spacing;
  }
  return computedSpacing;
};
var getResponsiveSpacing = (vertical, prefix, spacing) => {
  const defaultValue = getDefaultSpacingValue(prefix);
  const styles = {
    [`${prefix}Top`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Bottom`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Right`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Left`]: [defaultValue, defaultValue, defaultValue]
  };
  const spacingIsEmptyArray = Array.isArray(spacing) && spacing.length === 0;
  if (spacing === void 0 || spacingIsEmptyArray) {
    return styles;
  }
  vertical.forEach((isVertical, screenSize) => {
    const spacingForScreenSize = Array.isArray(spacing) ? spacing[screenSize] : spacing;
    if (isVertical) {
      styles[`${prefix}Top`][screenSize] = spacingForScreenSize;
      styles[`${prefix}Bottom`][screenSize] = spacingForScreenSize;
    } else {
      styles[`${prefix}Right`][screenSize] = spacingForScreenSize;
      styles[`${prefix}Left`][screenSize] = spacingForScreenSize;
    }
  });
  return styles;
};
var getOuterGutterPull = (gutter) => {
  if (Array.isArray(gutter)) {
    return gutter.map((value) => {
      if (value !== "space0") {
        return value.replace("space", "spaceNegative");
      }
      if (value === "space0") {
        return "space0";
      }
      return null;
    });
  }
  if (gutter === "space0") {
    return "space0";
  }
  if (gutter && typeof gutter === "string") {
    return gutter.replace("space", "spaceNegative");
  }
  return "auto";
};
var getStackedColumns = (vertical) => {
  if (Array.isArray(vertical)) {
    return vertical.map((value) => {
      if (typeof value === "boolean") {
        return value === true ? "100%" : "0";
      }
      return null;
    });
  }
  if (vertical) {
    return "100%";
  }
  return "0";
};
var getColumnPadding = ({vertical, gutter}) => {
  return Array.isArray(vertical) ? getResponsiveSpacing(vertical, "padding", gutter) : getSpacing(vertical, "padding", gutter);
};
var getColumnSpan = ({count, span}) => {
  if (Array.isArray(span) && count) {
    return span.map((value) => {
      return `${value / 12 * 100}%`;
    });
  }
  if (typeof span === "number" && count && count <= 12) {
    return `${span / 12 * 100}%`;
  }
  if (count !== void 0) {
    return `${1 / count * 100}%`;
  }
  return `${1 / 12 * 100}%`;
};
var getColumnOffset = (offset) => {
  if (Array.isArray(offset)) {
    return offset.map((value) => {
      return `${value / 12 * 100}%`;
    });
  }
  return `${offset / 12 * 100}%`;
};

// src/Grid.tsx
var getGutterStyles = (gutter, vertical = false) => {
  const margin = getOuterGutterPull(gutter);
  if (Array.isArray(vertical)) {
    return getResponsiveSpacing(vertical, "margin", margin);
  }
  return getSpacing(vertical, "margin", margin);
};
var getFlexDirection = (vertical) => {
  if (Array.isArray(vertical)) {
    return vertical.map((value) => {
      if (typeof value === "boolean") {
        return value === true ? "column" : "row";
      }
      return "row";
    });
  }
  if (vertical) {
    return "column";
  }
  return "row";
};
var Grid = forwardRef((_a, ref) => {
  var {as, children, element = "GRID", equalColumnHeights, gutter, marginTop, marginBottom, vertical = false} = _a, props = __rest(_a, ["as", "children", "element", "equalColumnHeights", "gutter", "marginTop", "marginBottom", "vertical"]);
  const GridColumns = useMemo(() => Children.map(children, (child) => isValidElement(child) ? cloneElement(child, {
    count: Children.count(children),
    gutter,
    vertical,
    stretchColumnContent: equalColumnHeights
  }) : child), [children, vertical, equalColumnHeights, gutter]);
  const gutterStyles = useMemo(() => getGutterStyles(gutter, vertical), [gutter, vertical]);
  const flexDirection = useMemo(() => getFlexDirection(vertical), [vertical]);
  return /* @__PURE__ */ createElement(Box, __assign(__assign(__assign(__assign({}, safelySpreadBoxProps(props)), {
    ref,
    as,
    alignItems: equalColumnHeights ? "stretch" : null,
    element,
    flexDirection,
    flexWrap: "wrap",
    display: "flex"
  }), gutterStyles), {
    marginTop,
    marginBottom,
    minWidth: "size0"
  }), GridColumns);
});
Grid.displayName = "Grid";
Grid.propTypes = {
  as: string,
  children: node.isRequired,
  equalColumnHeights: bool,
  element: string,
  vertical: ResponsiveProp(bool)
};

// src/Column.tsx
import {
  createElement as createElement2,
  forwardRef as forwardRef2,
  useMemo as useMemo2
} from "react";
import {
  number,
  string as string2
} from "prop-types";
import {Box as Box2, safelySpreadBoxProps as safelySpreadBoxProps2} from "@twilio-paste/box";
import {ResponsiveProp as ResponsiveProp2} from "@twilio-paste/style-props";
var getColumnStyles = ({
  count,
  span,
  gutter,
  offset,
  vertical,
  stretchColumnContent
}) => {
  const columnStyles = __assign({
    width: getColumnSpan({count, span})
  }, getColumnPadding({gutter, vertical}));
  if (offset) {
    columnStyles.marginLeft = getColumnOffset(offset);
  }
  if (vertical && !offset) {
    columnStyles.minWidth = getStackedColumns(vertical);
    columnStyles.marginLeft = "space0";
  }
  if (stretchColumnContent) {
    columnStyles.alignContent = "stretch";
    columnStyles.display = "flex";
  }
  return columnStyles;
};
var Column = forwardRef2((_a, ref) => {
  var {as, children, count, element = "COLUMN", gutter, offset, span, stretchColumnContent, vertical} = _a, props = __rest(_a, ["as", "children", "count", "element", "gutter", "offset", "span", "stretchColumnContent", "vertical"]);
  const ColumnStyles = useMemo2(() => getColumnStyles({count, gutter, offset, span, stretchColumnContent, vertical}), [count, gutter, offset, span, stretchColumnContent, vertical]);
  return /* @__PURE__ */ createElement2(Box2, __assign(__assign(__assign({}, safelySpreadBoxProps2(props)), ColumnStyles), {
    as,
    element,
    ref
  }), children);
});
Column.displayName = "Column";
Column.propTypes = {
  as: string2,
  element: string2,
  offset: ResponsiveProp2(number),
  span: ResponsiveProp2(number)
};
export {
  Column,
  Grid
};
