var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __assign = Object.assign;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __rest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// src/index.tsx
__export(exports, {
  Column: () => Column,
  Grid: () => Grid
});

// src/Grid.tsx
var React = __toModule(require("react"));
var PropTypes = __toModule(require("prop-types"));
var import_style_props = __toModule(require("@twilio-paste/style-props"));
var import_box = __toModule(require("@twilio-paste/box"));

// src/utils.tsx
var initDefaultSpacing = ({
  prefix,
  responsive,
  defaultValue
}) => {
  const getSpaceDefault = () => responsive ? new Array(3).fill(defaultValue) : defaultValue;
  return {
    [`${prefix}Top`]: getSpaceDefault(),
    [`${prefix}Bottom`]: getSpaceDefault(),
    [`${prefix}Right`]: getSpaceDefault(),
    [`${prefix}Left`]: getSpaceDefault()
  };
};
var getDefaultSpacingValue = (prefix) => prefix === "margin" ? "auto" : "space0";
var getSpacing = (vertical, prefix, spacing) => {
  const defaultValue = getDefaultSpacingValue(prefix);
  const computedSpacing = initDefaultSpacing({prefix, responsive: false, defaultValue});
  if (spacing === void 0) {
    return computedSpacing;
  }
  if (vertical) {
    computedSpacing[`${prefix}Top`] = spacing;
    computedSpacing[`${prefix}Bottom`] = spacing;
  } else {
    computedSpacing[`${prefix}Right`] = spacing;
    computedSpacing[`${prefix}Left`] = spacing;
  }
  return computedSpacing;
};
var getResponsiveSpacing = (vertical, prefix, spacing) => {
  const defaultValue = getDefaultSpacingValue(prefix);
  const styles = {
    [`${prefix}Top`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Bottom`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Right`]: [defaultValue, defaultValue, defaultValue],
    [`${prefix}Left`]: [defaultValue, defaultValue, defaultValue]
  };
  const spacingIsEmptyArray = Array.isArray(spacing) && spacing.length === 0;
  if (spacing === void 0 || spacingIsEmptyArray) {
    return styles;
  }
  vertical.forEach((isVertical, screenSize) => {
    const spacingForScreenSize = Array.isArray(spacing) ? spacing[screenSize] : spacing;
    if (isVertical) {
      styles[`${prefix}Top`][screenSize] = spacingForScreenSize;
      styles[`${prefix}Bottom`][screenSize] = spacingForScreenSize;
    } else {
      styles[`${prefix}Right`][screenSize] = spacingForScreenSize;
      styles[`${prefix}Left`][screenSize] = spacingForScreenSize;
    }
  });
  return styles;
};
var getOuterGutterPull = (gutter) => {
  if (Array.isArray(gutter)) {
    return gutter.map((value) => {
      if (value !== "space0") {
        return value.replace("space", "spaceNegative");
      }
      if (value === "space0") {
        return "space0";
      }
      return null;
    });
  }
  if (gutter === "space0") {
    return "space0";
  }
  if (gutter && typeof gutter === "string") {
    return gutter.replace("space", "spaceNegative");
  }
  return "auto";
};
var getStackedColumns = (vertical) => {
  if (Array.isArray(vertical)) {
    return vertical.map((value) => {
      if (typeof value === "boolean") {
        return value === true ? "100%" : "0";
      }
      return null;
    });
  }
  if (vertical) {
    return "100%";
  }
  return "0";
};
var getColumnPadding = ({vertical, gutter}) => {
  return Array.isArray(vertical) ? getResponsiveSpacing(vertical, "padding", gutter) : getSpacing(vertical, "padding", gutter);
};
var getColumnSpan = ({count, span}) => {
  if (Array.isArray(span) && count) {
    return span.map((value) => {
      return `${value / 12 * 100}%`;
    });
  }
  if (typeof span === "number" && count && count <= 12) {
    return `${span / 12 * 100}%`;
  }
  if (count !== void 0) {
    return `${1 / count * 100}%`;
  }
  return `${1 / 12 * 100}%`;
};
var getColumnOffset = (offset) => {
  if (Array.isArray(offset)) {
    return offset.map((value) => {
      return `${value / 12 * 100}%`;
    });
  }
  return `${offset / 12 * 100}%`;
};

// src/Grid.tsx
var getGutterStyles = (gutter, vertical = false) => {
  const margin = getOuterGutterPull(gutter);
  if (Array.isArray(vertical)) {
    return getResponsiveSpacing(vertical, "margin", margin);
  }
  return getSpacing(vertical, "margin", margin);
};
var getFlexDirection = (vertical) => {
  if (Array.isArray(vertical)) {
    return vertical.map((value) => {
      if (typeof value === "boolean") {
        return value === true ? "column" : "row";
      }
      return "row";
    });
  }
  if (vertical) {
    return "column";
  }
  return "row";
};
var Grid = React.forwardRef((_a, ref) => {
  var {as, children, element = "GRID", equalColumnHeights, gutter, marginTop, marginBottom, vertical = false} = _a, props = __rest(_a, ["as", "children", "element", "equalColumnHeights", "gutter", "marginTop", "marginBottom", "vertical"]);
  const GridColumns = React.useMemo(() => React.Children.map(children, (child) => React.isValidElement(child) ? React.cloneElement(child, {
    count: React.Children.count(children),
    gutter,
    vertical,
    stretchColumnContent: equalColumnHeights
  }) : child), [children, vertical, equalColumnHeights, gutter]);
  const gutterStyles = React.useMemo(() => getGutterStyles(gutter, vertical), [gutter, vertical]);
  const flexDirection = React.useMemo(() => getFlexDirection(vertical), [vertical]);
  return /* @__PURE__ */ React.createElement(import_box.Box, __assign(__assign(__assign(__assign({}, import_box.safelySpreadBoxProps(props)), {
    ref,
    as,
    alignItems: equalColumnHeights ? "stretch" : null,
    element,
    flexDirection,
    flexWrap: "wrap",
    display: "flex"
  }), gutterStyles), {
    marginTop,
    marginBottom,
    minWidth: "size0"
  }), GridColumns);
});
Grid.displayName = "Grid";
Grid.propTypes = {
  as: PropTypes.string,
  children: PropTypes.node.isRequired,
  equalColumnHeights: PropTypes.bool,
  element: PropTypes.string,
  vertical: import_style_props.ResponsiveProp(PropTypes.bool)
};

// src/Column.tsx
var React2 = __toModule(require("react"));
var PropTypes2 = __toModule(require("prop-types"));
var import_box2 = __toModule(require("@twilio-paste/box"));
var import_style_props2 = __toModule(require("@twilio-paste/style-props"));
var getColumnStyles = ({
  count,
  span,
  gutter,
  offset,
  vertical,
  stretchColumnContent
}) => {
  const columnStyles = __assign({
    width: getColumnSpan({count, span})
  }, getColumnPadding({gutter, vertical}));
  if (offset) {
    columnStyles.marginLeft = getColumnOffset(offset);
  }
  if (vertical && !offset) {
    columnStyles.minWidth = getStackedColumns(vertical);
    columnStyles.marginLeft = "space0";
  }
  if (stretchColumnContent) {
    columnStyles.alignContent = "stretch";
    columnStyles.display = "flex";
  }
  return columnStyles;
};
var Column = React2.forwardRef((_a, ref) => {
  var {as, children, count, element = "COLUMN", gutter, offset, span, stretchColumnContent, vertical} = _a, props = __rest(_a, ["as", "children", "count", "element", "gutter", "offset", "span", "stretchColumnContent", "vertical"]);
  const ColumnStyles = React2.useMemo(() => getColumnStyles({count, gutter, offset, span, stretchColumnContent, vertical}), [count, gutter, offset, span, stretchColumnContent, vertical]);
  return /* @__PURE__ */ React2.createElement(import_box2.Box, __assign(__assign(__assign({}, import_box2.safelySpreadBoxProps(props)), ColumnStyles), {
    as,
    element,
    ref
  }), children);
});
Column.displayName = "Column";
Column.propTypes = {
  as: PropTypes2.string,
  element: PropTypes2.string,
  offset: import_style_props2.ResponsiveProp(PropTypes2.number),
  span: import_style_props2.ResponsiveProp(PropTypes2.number)
};
