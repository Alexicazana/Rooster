var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __assign = Object.assign;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __rest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  __markAsModule(target);
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  if (module2 && module2.__esModule)
    return module2;
  return __exportStar(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", {value: module2, enumerable: true}), module2);
};

// ../../../../node_modules/autosize/dist/autosize.js
var require_autosize = __commonJS((exports2, module2) => {
  /*!
  	autosize 4.0.2
  	license: MIT
  	http://www.jacklmoore.com/autosize
  */
  (function(global, factory) {
    if (typeof define === "function" && define.amd) {
      define(["module", "exports"], factory);
    } else if (typeof exports2 !== "undefined") {
      factory(module2, exports2);
    } else {
      var mod = {
        exports: {}
      };
      factory(mod, mod.exports);
      global.autosize = mod.exports;
    }
  })(exports2, function(module3, exports3) {
    "use strict";
    var map = typeof Map === "function" ? new Map() : function() {
      var keys = [];
      var values = [];
      return {
        has: function has(key) {
          return keys.indexOf(key) > -1;
        },
        get: function get(key) {
          return values[keys.indexOf(key)];
        },
        set: function set(key, value) {
          if (keys.indexOf(key) === -1) {
            keys.push(key);
            values.push(value);
          }
        },
        delete: function _delete(key) {
          var index = keys.indexOf(key);
          if (index > -1) {
            keys.splice(index, 1);
            values.splice(index, 1);
          }
        }
      };
    }();
    var createEvent = function createEvent2(name) {
      return new Event(name, {bubbles: true});
    };
    try {
      new Event("test");
    } catch (e) {
      createEvent = function createEvent2(name) {
        var evt = document.createEvent("Event");
        evt.initEvent(name, true, false);
        return evt;
      };
    }
    function assign(ta) {
      if (!ta || !ta.nodeName || ta.nodeName !== "TEXTAREA" || map.has(ta))
        return;
      var heightOffset = null;
      var clientWidth = null;
      var cachedHeight = null;
      function init() {
        var style = window.getComputedStyle(ta, null);
        if (style.resize === "vertical") {
          ta.style.resize = "none";
        } else if (style.resize === "both") {
          ta.style.resize = "horizontal";
        }
        if (style.boxSizing === "content-box") {
          heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
        } else {
          heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
        }
        if (isNaN(heightOffset)) {
          heightOffset = 0;
        }
        update2();
      }
      function changeOverflow(value) {
        {
          var width = ta.style.width;
          ta.style.width = "0px";
          ta.offsetWidth;
          ta.style.width = width;
        }
        ta.style.overflowY = value;
      }
      function getParentOverflows(el) {
        var arr = [];
        while (el && el.parentNode && el.parentNode instanceof Element) {
          if (el.parentNode.scrollTop) {
            arr.push({
              node: el.parentNode,
              scrollTop: el.parentNode.scrollTop
            });
          }
          el = el.parentNode;
        }
        return arr;
      }
      function resize() {
        if (ta.scrollHeight === 0) {
          return;
        }
        var overflows = getParentOverflows(ta);
        var docTop = document.documentElement && document.documentElement.scrollTop;
        ta.style.height = "";
        ta.style.height = ta.scrollHeight + heightOffset + "px";
        clientWidth = ta.clientWidth;
        overflows.forEach(function(el) {
          el.node.scrollTop = el.scrollTop;
        });
        if (docTop) {
          document.documentElement.scrollTop = docTop;
        }
      }
      function update2() {
        resize();
        var styleHeight = Math.round(parseFloat(ta.style.height));
        var computed = window.getComputedStyle(ta, null);
        var actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;
        if (actualHeight < styleHeight) {
          if (computed.overflowY === "hidden") {
            changeOverflow("scroll");
            resize();
            actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
          }
        } else {
          if (computed.overflowY !== "hidden") {
            changeOverflow("hidden");
            resize();
            actualHeight = computed.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
          }
        }
        if (cachedHeight !== actualHeight) {
          cachedHeight = actualHeight;
          var evt = createEvent("autosize:resized");
          try {
            ta.dispatchEvent(evt);
          } catch (err) {
          }
        }
      }
      var pageResize = function pageResize2() {
        if (ta.clientWidth !== clientWidth) {
          update2();
        }
      };
      var destroy2 = function(style) {
        window.removeEventListener("resize", pageResize, false);
        ta.removeEventListener("input", update2, false);
        ta.removeEventListener("keyup", update2, false);
        ta.removeEventListener("autosize:destroy", destroy2, false);
        ta.removeEventListener("autosize:update", update2, false);
        Object.keys(style).forEach(function(key) {
          ta.style[key] = style[key];
        });
        map.delete(ta);
      }.bind(ta, {
        height: ta.style.height,
        resize: ta.style.resize,
        overflowY: ta.style.overflowY,
        overflowX: ta.style.overflowX,
        wordWrap: ta.style.wordWrap
      });
      ta.addEventListener("autosize:destroy", destroy2, false);
      if ("onpropertychange" in ta && "oninput" in ta) {
        ta.addEventListener("keyup", update2, false);
      }
      window.addEventListener("resize", pageResize, false);
      ta.addEventListener("input", update2, false);
      ta.addEventListener("autosize:update", update2, false);
      ta.style.overflowX = "hidden";
      ta.style.wordWrap = "break-word";
      map.set(ta, {
        destroy: destroy2,
        update: update2
      });
      init();
    }
    function destroy(ta) {
      var methods = map.get(ta);
      if (methods) {
        methods.destroy();
      }
    }
    function update(ta) {
      var methods = map.get(ta);
      if (methods) {
        methods.update();
      }
    }
    var autosize = null;
    if (typeof window === "undefined" || typeof window.getComputedStyle !== "function") {
      autosize = function autosize2(el) {
        return el;
      };
      autosize.destroy = function(el) {
        return el;
      };
      autosize.update = function(el) {
        return el;
      };
    } else {
      autosize = function autosize2(el, options) {
        if (el) {
          Array.prototype.forEach.call(el.length ? el : [el], function(x) {
            return assign(x, options);
          });
        }
        return el;
      };
      autosize.destroy = function(el) {
        if (el) {
          Array.prototype.forEach.call(el.length ? el : [el], destroy);
        }
        return el;
      };
      autosize.update = function(el) {
        if (el) {
          Array.prototype.forEach.call(el.length ? el : [el], update);
        }
        return el;
      };
    }
    exports3.default = autosize;
    module3.exports = exports3["default"];
  });
});

// ../../../../node_modules/computed-style/dist/computedStyle.commonjs.js
var require_computedStyle_commonjs = __commonJS((exports2, module2) => {
  var computedStyle = function(el, prop, getComputedStyle) {
    getComputedStyle = window.getComputedStyle;
    return (getComputedStyle ? getComputedStyle(el) : el.currentStyle)[prop.replace(/-(\w)/gi, function(word, letter) {
      return letter.toUpperCase();
    })];
  };
  module2.exports = computedStyle;
});

// ../../../../node_modules/line-height/lib/line-height.js
var require_line_height = __commonJS((exports2, module2) => {
  var computedStyle = require_computedStyle_commonjs();
  function lineHeight(node) {
    var lnHeightStr = computedStyle(node, "line-height");
    var lnHeight = parseFloat(lnHeightStr, 10);
    if (lnHeightStr === lnHeight + "") {
      var _lnHeightStyle = node.style.lineHeight;
      node.style.lineHeight = lnHeightStr + "em";
      lnHeightStr = computedStyle(node, "line-height");
      lnHeight = parseFloat(lnHeightStr, 10);
      if (_lnHeightStyle) {
        node.style.lineHeight = _lnHeightStyle;
      } else {
        delete node.style.lineHeight;
      }
    }
    if (lnHeightStr.indexOf("pt") !== -1) {
      lnHeight *= 4;
      lnHeight /= 3;
    } else if (lnHeightStr.indexOf("mm") !== -1) {
      lnHeight *= 96;
      lnHeight /= 25.4;
    } else if (lnHeightStr.indexOf("cm") !== -1) {
      lnHeight *= 96;
      lnHeight /= 2.54;
    } else if (lnHeightStr.indexOf("in") !== -1) {
      lnHeight *= 96;
    } else if (lnHeightStr.indexOf("pc") !== -1) {
      lnHeight *= 16;
    }
    lnHeight = Math.round(lnHeight);
    if (lnHeightStr === "normal") {
      var nodeName = node.nodeName;
      var _node = document.createElement(nodeName);
      _node.innerHTML = "&nbsp;";
      if (nodeName.toUpperCase() === "TEXTAREA") {
        _node.setAttribute("rows", "1");
      }
      var fontSizeStr = computedStyle(node, "font-size");
      _node.style.fontSize = fontSizeStr;
      _node.style.padding = "0px";
      _node.style.border = "0px";
      var body = document.body;
      body.appendChild(_node);
      var height = _node.offsetHeight;
      lnHeight = height;
      body.removeChild(_node);
    }
    return lnHeight;
  }
  module2.exports = lineHeight;
});

// ../../../../node_modules/react-autosize-textarea/lib/TextareaAutosize.js
var require_TextareaAutosize = __commonJS((exports2) => {
  "use strict";
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (b.hasOwnProperty(p))
          d[p] = b[p];
    };
    return function(d, b) {
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __assign2 = exports2 && exports2.__assign || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  var __rest2 = exports2 && exports2.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
        if (e.indexOf(p[i]) < 0)
          t[p[i]] = s[p[i]];
    }
    return t;
  };
  exports2.__esModule = true;
  var React2 = require("react");
  var PropTypes2 = require("prop-types");
  var autosize = require_autosize();
  var _getLineHeight = require_line_height();
  var getLineHeight = _getLineHeight;
  var RESIZED = "autosize:resized";
  var TextareaAutosizeClass = function(_super) {
    __extends(TextareaAutosizeClass2, _super);
    function TextareaAutosizeClass2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.state = {
        lineHeight: null
      };
      _this.textarea = null;
      _this.onResize = function(e) {
        if (_this.props.onResize) {
          _this.props.onResize(e);
        }
      };
      _this.updateLineHeight = function() {
        if (_this.textarea) {
          _this.setState({
            lineHeight: getLineHeight(_this.textarea)
          });
        }
      };
      _this.onChange = function(e) {
        var onChange = _this.props.onChange;
        _this.currentValue = e.currentTarget.value;
        onChange && onChange(e);
      };
      return _this;
    }
    TextareaAutosizeClass2.prototype.componentDidMount = function() {
      var _this = this;
      var _a = this.props, maxRows = _a.maxRows, async = _a.async;
      if (typeof maxRows === "number") {
        this.updateLineHeight();
      }
      if (typeof maxRows === "number" || async) {
        setTimeout(function() {
          return _this.textarea && autosize(_this.textarea);
        });
      } else {
        this.textarea && autosize(this.textarea);
      }
      if (this.textarea) {
        this.textarea.addEventListener(RESIZED, this.onResize);
      }
    };
    TextareaAutosizeClass2.prototype.componentWillUnmount = function() {
      if (this.textarea) {
        this.textarea.removeEventListener(RESIZED, this.onResize);
        autosize.destroy(this.textarea);
      }
    };
    TextareaAutosizeClass2.prototype.render = function() {
      var _this = this;
      var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest2(_b, ["onResize", "maxRows", "onChange", "style", "innerRef", "children"]), lineHeight = _a.state.lineHeight;
      var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;
      return React2.createElement("textarea", __assign2({}, props, {onChange: this.onChange, style: maxHeight ? __assign2({}, style, {maxHeight}) : style, ref: function(element) {
        _this.textarea = element;
        if (typeof _this.props.innerRef === "function") {
          _this.props.innerRef(element);
        } else if (_this.props.innerRef) {
          _this.props.innerRef.current = element;
        }
      }}), children);
    };
    TextareaAutosizeClass2.prototype.componentDidUpdate = function() {
      this.textarea && autosize.update(this.textarea);
    };
    TextareaAutosizeClass2.defaultProps = {
      rows: 1,
      async: false
    };
    TextareaAutosizeClass2.propTypes = {
      rows: PropTypes2.number,
      maxRows: PropTypes2.number,
      onResize: PropTypes2.func,
      innerRef: PropTypes2.any,
      async: PropTypes2.bool
    };
    return TextareaAutosizeClass2;
  }(React2.Component);
  exports2.TextareaAutosize = React2.forwardRef(function(props, ref) {
    return React2.createElement(TextareaAutosizeClass, __assign2({}, props, {innerRef: ref}));
  });
});

// ../../../../node_modules/react-autosize-textarea/lib/index.js
var require_lib = __commonJS((exports2) => {
  "use strict";
  exports2.__esModule = true;
  var TextareaAutosize_1 = require_TextareaAutosize();
  exports2["default"] = TextareaAutosize_1.TextareaAutosize;
});

// src/index.tsx
__export(exports, {
  TextArea: () => TextArea
});

// src/TextArea.tsx
var React = __toModule(require("react"));
var PropTypes = __toModule(require("prop-types"));
var import_react_autosize_textarea = __toModule(require_lib());
var import_styling_library = __toModule(require("@twilio-paste/styling-library"));
var import_box = __toModule(require("@twilio-paste/box"));
var import_input_box = __toModule(require("@twilio-paste/input-box"));
var TextAreaElement = import_styling_library.styled(import_react_autosize_textarea.default)((props) => import_styling_library.css({
  appearance: "none",
  background: "transparent",
  border: "none",
  borderRadius: "borderRadius20",
  boxShadow: "none",
  color: "inherit",
  display: "block",
  fontFamily: "inherit",
  fontSize: "fontSize30",
  fontWeight: "fontWeightMedium",
  lineHeight: "lineHeight20",
  maxHeight: "size30",
  outline: "none",
  paddingBottom: "space30",
  paddingLeft: "space40",
  paddingRight: "space40",
  paddingTop: "space30",
  resize: "vertical",
  width: "100%",
  "&::placeholder": {
    color: props.variant === "inverse" ? "colorTextInverseWeak" : "colorTextWeak",
    fontStyle: "italic"
  },
  "&:focus::placeholder": {
    color: props.variant === "inverse" ? "colorTextInverseWeak" : "colorTextWeak"
  },
  "&:disabled": {
    color: props.variant === "inverse" ? "colorTextInverseWeaker" : "colorTextWeaker",
    cursor: "not-allowed",
    "-webkit-text-fill-color": props.variant === "inverse" ? "colorTextInverseWeaker" : "colorTextWeaker",
    "-webkit-opacity": "1"
  }
}), import_box.getCustomElementStyles);
var TextArea = React.forwardRef((_a, ref) => {
  var {
    children,
    disabled,
    element = "TEXTAREA",
    hasError,
    insertBefore,
    insertAfter,
    readOnly,
    variant,
    size,
    height,
    width
  } = _a, props = __rest(_a, [
    "children",
    "disabled",
    "element",
    "hasError",
    "insertBefore",
    "insertAfter",
    "readOnly",
    "variant",
    "size",
    "height",
    "width"
  ]);
  return /* @__PURE__ */ React.createElement(import_input_box.InputBox, {
    disabled,
    element,
    hasError,
    insertAfter,
    insertBefore,
    readOnly,
    variant
  }, /* @__PURE__ */ React.createElement(TextAreaElement, __assign(__assign({}, import_box.safelySpreadBoxProps(props)), {
    async: true,
    "aria-invalid": hasError,
    "aria-readonly": readOnly,
    disabled,
    "data-paste-element": `${element}_ELEMENT`,
    readOnly,
    ref,
    rows: 3,
    spellCheck: true,
    variant
  }), children));
});
TextArea.displayName = "TextArea";
TextArea.propTypes = {
  disabled: PropTypes.bool,
  element: PropTypes.string,
  hasError: PropTypes.bool,
  id: PropTypes.string,
  name: PropTypes.string,
  onBlur: PropTypes.func,
  onChange: PropTypes.func,
  onFocus: PropTypes.func,
  placeholder: PropTypes.string,
  readOnly: PropTypes.bool,
  required: PropTypes.bool
};
